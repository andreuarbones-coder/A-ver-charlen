<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceStream Pro</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Firebase SDKs (Modular) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, push, set, onChildAdded, remove, serverTimestamp, query, limitToLast, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
        import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";
        
        // Exponer clases al window para uso global
        window.FirebaseMods = { initializeApp, getDatabase, ref, push, set, onChildAdded, remove, serverTimestamp, query, limitToLast, onValue, getStorage, sRef, uploadBytes, getDownloadURL };
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Animations */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .recording-pulse {
            animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        @keyframes sound-wave {
            0% { height: 4px; }
            50% { height: 16px; }
            100% { height: 4px; }
        }
        .sound-bar {
            width: 4px;
            background: #34d399;
            border-radius: 2px;
            animation: sound-wave 0.5s infinite ease-in-out;
        }
        .sound-bar:nth-child(2) { animation-delay: 0.1s; }
        .sound-bar:nth-child(3) { animation-delay: 0.2s; }
        .sound-bar:nth-child(4) { animation-delay: 0.3s; }

        .glass-panel {
            background: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .no-select {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #34d399;
            cursor: pointer;
            margin-top: -6px; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen overflow-hidden flex flex-col font-sans">

    <!-- SETUP MODAL (Settings) -->
    <div id="setupModal" class="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4 hidden">
        <div class="bg-gray-800 p-6 rounded-2xl max-w-md w-full border border-gray-700 shadow-2xl">
            <h2 class="text-2xl font-bold mb-4 text-emerald-400 flex items-center gap-2">
                <i data-lucide="settings"></i> Configuración
            </h2>
            
            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Tu Nombre</label>
            <input type="text" id="setupName" placeholder="Ej: CyberPunk" class="w-full bg-gray-900 border border-gray-700 rounded p-2 mb-4 text-white focus:outline-none focus:border-emerald-500">

            <!-- Volume Control in Settings -->
            <label class="block text-xs font-bold text-gray-500 uppercase mb-2">Volumen de Recepción</label>
            <div class="flex items-center gap-3 mb-6 bg-gray-900 p-3 rounded border border-gray-700">
                <i data-lucide="volume-2" class="text-gray-400 w-5 h-5"></i>
                <input type="range" id="volumeSliderModal" min="0" max="1" step="0.1" value="1" class="w-full">
            </div>

            <div id="manualConfigSection">
                <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Firebase Config (JSON)</label>
                <textarea id="setupFirebase" rows="5" placeholder='{"apiKey": "...", ...}' class="w-full bg-gray-900 border border-gray-700 rounded p-2 mb-4 text-xs font-mono text-green-400 focus:outline-none focus:border-emerald-500"></textarea>

                <label class="block text-xs font-bold text-gray-500 uppercase mb-1">OpenAI API Key (Opcional)</label>
                <input type="password" id="setupOpenAI" placeholder="sk-..." class="w-full bg-gray-900 border border-gray-700 rounded p-2 mb-6 text-white focus:outline-none focus:border-emerald-500">
            </div>

            <button id="saveSetupBtn" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 rounded-xl transition-all">
                Guardar y Entrar
            </button>
        </div>
    </div>

    <!-- HEADER -->
    <header class="glass-panel p-4 flex justify-between items-center z-10 shadow-lg relative">
        <div class="flex items-center gap-3">
            <div class="w-10 h-10 rounded-full bg-gradient-to-tr from-emerald-500 to-cyan-500 flex items-center justify-center font-bold text-lg shadow-lg" id="userAvatar">
                ?
            </div>
            <div>
                <h1 class="font-bold text-lg tracking-wide">VoiceStream</h1>
                <div class="flex items-center gap-1.5">
                    <span class="w-2 h-2 rounded-full bg-emerald-500 animate-pulse"></span>
                    <span class="text-xs text-gray-400" id="statusText">Conectando...</span>
                </div>
            </div>
        </div>
        <button id="settingsBtn" class="p-2 text-gray-400 hover:text-white transition-colors">
            <i data-lucide="settings"></i>
        </button>
    </header>

    <!-- RECEIVING INDICATOR -->
    <div id="receivingBanner" class="hidden w-full bg-gray-800/90 border-b border-emerald-500/50 p-2 flex items-center justify-center gap-3 backdrop-blur-sm z-0 animate-in slide-in-from-top duration-300 absolute top-[72px] left-0">
        <div class="flex items-end gap-1 h-4">
            <div class="sound-bar"></div>
            <div class="sound-bar"></div>
            <div class="sound-bar"></div>
            <div class="sound-bar"></div>
        </div>
        <span class="text-sm font-bold text-emerald-400" id="receivingText">Recibiendo audio...</span>
    </div>

    <!-- CHAT AREA -->
    <main id="chatArea" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth pb-32">
        <div class="text-center text-gray-500 text-sm my-8">
            <p>Bienvenido al canal seguro.</p>
            <p>Mantén presionado el micrófono para transmitir en vivo.</p>
        </div>
    </main>

    <!-- INPUT AREA -->
    <footer class="fixed bottom-0 w-full glass-panel p-4 pb-6 z-20">
        <!-- Audio Recording Indicator -->
        <div id="liveIndicator" class="hidden absolute -top-10 left-1/2 transform -translate-x-1/2 bg-red-500/90 text-white px-4 py-1 rounded-full text-xs font-bold flex items-center gap-2 shadow-lg backdrop-blur pointer-events-none">
            <span class="animate-ping absolute inline-flex h-2 w-2 rounded-full bg-white opacity-75"></span>
            <span class="relative inline-flex rounded-full h-2 w-2 bg-white"></span>
            TRANSMITIENDO...
        </div>

        <div class="flex items-end gap-3 max-w-4xl mx-auto">
            <label class="p-3 text-gray-400 hover:text-cyan-400 cursor-pointer transition-colors bg-gray-800 rounded-full">
                <input type="file" id="imageInput" accept="image/*" class="hidden">
                <i data-lucide="image"></i>
            </label>

            <div class="flex-1 bg-gray-800 rounded-2xl flex items-center border border-gray-700 focus-within:border-cyan-500 transition-colors">
                <input type="text" id="messageInput" placeholder="Escribe un mensaje..." class="w-full bg-transparent p-3 text-white focus:outline-none rounded-2xl" autocomplete="off">
                <button id="sendBtn" class="p-3 text-cyan-500 hover:text-cyan-300 hidden">
                    <i data-lucide="send"></i>
                </button>
            </div>

            <!-- Botón de Micrófono con eventos mejorados -->
            <button id="micBtn" class="no-select w-12 h-12 rounded-full bg-gradient-to-r from-emerald-600 to-teal-600 flex items-center justify-center text-white shadow-lg active:scale-95 transition-transform touch-none select-none">
                <i data-lucide="mic"></i>
            </button>
        </div>
    </footer>

    <!-- LOGIC -->
    <script type="module">
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyASWpIx5lvoYHHcyQzv3A2sJfU-TtNwIO8",
            authDomain: "a-ver-charlen.firebaseapp.com",
            databaseURL: "https://a-ver-charlen-default-rtdb.firebaseio.com", 
            projectId: "a-ver-charlen",
            storageBucket: "a-ver-charlen.firebasestorage.app",
            messagingSenderId: "414933228498",
            appId: "1:414933228498:web:fae4c31dfa855addd7c60b"
        };
        
        const OPENAI_KEY = null; 
        
        const state = {
            user: { id: null, name: 'Anon' },
            config: { firebase: FIREBASE_CONFIG, openai: OPENAI_KEY },
            volume: 1.0,
            isRecording: false,
            audioContext: null,
            nextPlayTime: 0,
            mediaRecorder: null,
            stream: null,
            fullAudioChunks: [], // Almacena todo para el archivo final
            streamId: null,
            chunkInterval: null
        };

        const els = {
            setupModal: document.getElementById('setupModal'),
            setupName: document.getElementById('setupName'),
            volumeSliderModal: document.getElementById('volumeSliderModal'),
            manualConfigSection: document.getElementById('manualConfigSection'),
            setupFirebase: document.getElementById('setupFirebase'),
            setupOpenAI: document.getElementById('setupOpenAI'),
            saveSetupBtn: document.getElementById('saveSetupBtn'),
            chatArea: document.getElementById('chatArea'),
            messageInput: document.getElementById('messageInput'),
            sendBtn: document.getElementById('sendBtn'),
            micBtn: document.getElementById('micBtn'),
            liveIndicator: document.getElementById('liveIndicator'),
            receivingBanner: document.getElementById('receivingBanner'),
            receivingText: document.getElementById('receivingText'),
            imageInput: document.getElementById('imageInput'),
            settingsBtn: document.getElementById('settingsBtn'),
            userAvatar: document.getElementById('userAvatar'),
            statusText: document.getElementById('statusText')
        };

        let db, storage;

        // --------------------------------------------------------------------------
        // AUDIO ENGINE FIXED (Chunking Replay)
        // --------------------------------------------------------------------------
        class AudioEngine {
            constructor() {
                this.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new this.AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = state.volume;
                this.masterGain.connect(this.ctx.destination);
            }

            setVolume(value) {
                state.volume = value;
                if(this.masterGain) this.masterGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.1);
            }

            resumeContext() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }

            playBeep(freq = 440) {
                this.resumeContext();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            async startRecording(onChunk, onStop) {
                if (state.isRecording) return;
                
                this.resumeContext();
                this.playBeep(600); // Start Beep

                try {
                    // Pedimos el stream una sola vez
                    state.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    state.streamId = `stream_${Date.now()}_${state.user.id}`;
                    state.fullAudioChunks = [];
                    
                    const options = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? { mimeType: 'audio/webm;codecs=opus' } : {};
                    
                    // Función interna para crear una instancia de grabadora corta
                    const startSlice = () => {
                        if (!state.isRecording) return;

                        // Creamos una nueva instancia cada vez para forzar HEADER en cada chunk
                        const recorder = new MediaRecorder(state.stream, options);
                        
                        recorder.ondataavailable = async (e) => {
                            if (e.data.size > 0) {
                                // Guardamos para el archivo final
                                state.fullAudioChunks.push(e.data);
                                
                                // Enviamos chunk válido (con header propio)
                                const reader = new FileReader();
                                reader.readAsDataURL(e.data);
                                reader.onloadend = () => {
                                    const base64data = reader.result.split(',')[1];
                                    onChunk(state.streamId, base64data);
                                };
                            }
                        };

                        recorder.start();
                        
                        // Detener esta slice en X ms
                        setTimeout(() => {
                            if (recorder.state === 'recording') recorder.stop();
                        }, 800); // 800ms slices
                    };

                    state.isRecording = true;
                    updateMicUI(true);

                    // Loop de grabación
                    startSlice(); // Primero inmediato
                    state.chunkInterval = setInterval(startSlice, 850); // Loop con pequeño solapamiento/gap

                } catch (err) {
                    console.error("Mic Error:", err);
                    alert("Error Micrófono. Verifica permisos.");
                    state.isRecording = false;
                }
            }

            stopRecording(onFinalize) {
                if (!state.isRecording) return;
                
                state.isRecording = false;
                clearInterval(state.chunkInterval);
                this.playBeep(400); // Stop Beep

                // Detener tracks del micrófono
                if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                }
                updateMicUI(false);

                // Compilar el audio final completo
                const fullBlob = new Blob(state.fullAudioChunks, { type: 'audio/webm' });
                onFinalize(fullBlob, state.streamId);
            }

            async playStreamChunk(base64data) {
                this.resumeContext();
                try {
                    // Decodificar Base64
                    const binaryString = window.atob(base64data);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
                    
                    // IMPORTANTE: decodeAudioData funciona mejor con archivos completos.
                    // Al reiniciar el MediaRecorder, cada chunk es un archivo mini válido.
                    const audioBuffer = await this.ctx.decodeAudioData(bytes.buffer);
                    
                    const source = this.ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.masterGain);

                    const now = this.ctx.currentTime;
                    // Lógica de cola (Jitter Buffer simple)
                    // Si el siguiente tiempo está en el pasado, resetear a 'ahora'
                    const startAt = Math.max(now, state.nextPlayTime);
                    source.start(startAt);
                    
                    // Actualizar puntero de tiempo
                    state.nextPlayTime = startAt + audioBuffer.duration;

                } catch (e) {
                    console.error("Error decoding audio (posible chunk incompleto):", e);
                }
            }
        }
        const audioEngine = new AudioEngine();

        // --------------------------------------------------------------------------
        // FIREBASE
        // --------------------------------------------------------------------------
        async function initFirebase() {
            if (!state.config.firebase) { showSetup(true); return; }
            const { initializeApp, getDatabase, getStorage } = window.FirebaseMods;
            try {
                let app;
                try { app = initializeApp(state.config.firebase); } catch(e) {}
                db = getDatabase(app);
                storage = getStorage(app);
                els.statusText.innerText = "En línea";
                els.statusText.classList.remove('text-red-400');
                startListeners();
            } catch (e) {
                console.error("Firebase init failed", e);
                els.statusText.innerText = "Error Conexión";
                showSetup(true);
            }
        }

        function startListeners() {
            const { ref, onChildAdded, query, limitToLast } = window.FirebaseMods;

            const chatRef = query(ref(db, 'messages'), limitToLast(50));
            onChildAdded(chatRef, (snapshot) => renderMessage(snapshot.val(), snapshot.key));

            const streamRef = ref(db, 'stream');
            onChildAdded(streamRef, (snapshot) => {
                const streamSession = snapshot.val();
                // Solo escuchar si no soy yo y es reciente (menos de 30s)
                const isRecent = (Date.now() - (streamSession.timestamp || 0)) < 30000;
                
                if (streamSession.userId !== state.user.id && isRecent) {
                    const chunksRef = ref(db, `stream/${snapshot.key}/chunks`);
                    onChildAdded(chunksRef, (chunkSnap) => {
                        audioEngine.playStreamChunk(chunkSnap.val());
                        showReceivingIndicator(streamSession.userName);
                    });
                }
            });
        }

        async function sendLiveChunk(streamId, base64) {
            const { ref, push, set } = window.FirebaseMods;
            const chunkRef = push(ref(db, `stream/${streamId}/chunks`));
            await set(chunkRef, base64);
            // Metadata redundante para asegurar acceso rápido
            await set(ref(db, `stream/${streamId}/userId`), state.user.id);
            await set(ref(db, `stream/${streamId}/userName`), state.user.name);
            await set(ref(db, `stream/${streamId}/timestamp`), Date.now());
        }

        async function finalizeAudio(blob, streamId) {
            const { ref, push, set, serverTimestamp, remove } = window.FirebaseMods;
            const { ref: sRef, uploadBytes, getDownloadURL } = window.FirebaseMods;

            const filename = `audios/${Date.now()}_${state.user.id}.webm`;
            const storageRef = sRef(storage, filename);
            
            try {
                await uploadBytes(storageRef, blob);
                const audioUrl = await getDownloadURL(storageRef);

                let transcript = "";
                if (state.config.openai) transcript = await transcribeAudio(blob);

                await set(push(ref(db, 'messages')), {
                    type: 'audio',
                    userId: state.user.id,
                    userName: state.user.name,
                    content: audioUrl,
                    transcript: transcript,
                    timestamp: serverTimestamp()
                });

                setTimeout(() => remove(ref(db, `stream/${streamId}`)), 2000);
            } catch (e) { console.error("Upload failed", e); }
        }

        async function transcribeAudio(blob) {
            const formData = new FormData();
            formData.append("file", blob, "audio.webm");
            formData.append("model", "whisper-1");
            try {
                const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${state.config.openai}` },
                    body: formData
                });
                const data = await response.json();
                return data.text || "";
            } catch (error) { return ""; }
        }

        // --------------------------------------------------------------------------
        // UI
        // --------------------------------------------------------------------------
        function showSetup(forceManual = false) {
            els.setupModal.classList.remove('hidden');
            const savedName = localStorage.getItem('vs_name');
            if (savedName) els.setupName.value = savedName;
            if (!forceManual && state.config.firebase) els.manualConfigSection.classList.add('hidden');
            else els.manualConfigSection.classList.remove('hidden');
        }

        function renderMessage(msg, key) {
            const isMe = msg.userId === state.user.id;
            const div = document.createElement('div');
            div.className = `flex flex-col ${isMe ? 'items-end' : 'items-start'} mb-4 animate-in fade-in slide-in-from-bottom-2 duration-300`;
            
            let content = '';
            if (msg.type === 'text') content = `<p class="text-sm">${escapeHtml(msg.content)}</p>`;
            else if (msg.type === 'image') content = `<img src="${msg.content}" class="max-w-[200px] rounded-lg border border-gray-600">`;
            else if (msg.type === 'audio') content = `
                <div class="flex items-center gap-2 min-w-[200px]">
                    <button onclick="this.nextElementSibling.play()" class="p-2 bg-gray-700 rounded-full hover:bg-gray-600"><i data-lucide="play" class="w-4 h-4"></i></button>
                    <audio src="${msg.content}" class="hidden" onplay="audioEngine.resumeContext()"></audio>
                    <div class="flex-1">
                        <div class="h-1 bg-gray-700 rounded w-full overflow-hidden"><div class="h-full bg-cyan-500 w-1/2"></div></div>
                        ${msg.transcript ? `<p class="text-[10px] text-gray-400 mt-1 italic">"${msg.transcript}"</p>` : ''}
                    </div>
                </div>`;

            div.innerHTML = `
                <span class="text-[10px] text-gray-500 mb-1 px-1">${msg.userName}</span>
                <div class="${isMe ? 'bg-emerald-700 text-white rounded-br-none' : 'bg-gray-700 text-gray-200 rounded-bl-none'} p-3 rounded-2xl shadow-md max-w-[85%] break-words">
                    ${content}
                </div>`;
            els.chatArea.appendChild(div);
            els.chatArea.scrollTop = els.chatArea.scrollHeight;
            lucide.createIcons();
        }

        function updateMicUI(recording) {
            if (recording) {
                els.micBtn.classList.add('bg-red-600', 'recording-pulse');
                els.micBtn.classList.remove('bg-gradient-to-r', 'from-emerald-600', 'to-teal-600');
                els.liveIndicator.classList.remove('hidden');
            } else {
                els.micBtn.classList.remove('bg-red-600', 'recording-pulse');
                els.micBtn.classList.add('bg-gradient-to-r', 'from-emerald-600', 'to-teal-600');
                els.liveIndicator.classList.add('hidden');
            }
        }

        function showReceivingIndicator(name) {
            els.receivingText.innerText = `${name} está hablando...`;
            els.receivingBanner.classList.remove('hidden');
            clearTimeout(window.talkTimeout);
            window.talkTimeout = setTimeout(() => {
                els.receivingBanner.classList.add('hidden');
            }, 2000);
        }

        // LISTENERS
        els.volumeSliderModal.addEventListener('input', (e) => audioEngine.setVolume(parseFloat(e.target.value)));
        document.body.addEventListener('click', () => audioEngine.resumeContext(), { once: true });

        const localData = JSON.parse(localStorage.getItem('vs_config') || '{}');
        if (!state.config.firebase && localData.config?.firebase) {
            state.config.firebase = localData.config.firebase;
            state.config.openai = localData.config.openai;
        }
        if (localData.user) state.user = localData.user;
        else state.user.id = crypto.randomUUID();

        els.saveSetupBtn.addEventListener('click', () => {
            const name = els.setupName.value || 'Anon';
            state.user.name = name;
            localStorage.setItem('vs_name', name);
            if (!state.config.firebase) {
                try {
                    const fbConfig = JSON.parse(els.setupFirebase.value);
                    const openAI = els.setupOpenAI.value;
                    state.config.firebase = fbConfig;
                    state.config.openai = openAI;
                    localStorage.setItem('vs_config', JSON.stringify({ user: state.user, config: state.config }));
                } catch(e) { alert("JSON Inválido"); return; }
            } else {
                localStorage.setItem('vs_config', JSON.stringify({ user: state.user, config: null }));
            }
            els.setupModal.classList.add('hidden');
            els.userAvatar.innerText = name.substring(0,2).toUpperCase();
            initFirebase();
        });

        els.settingsBtn.addEventListener('click', () => showSetup(false));
        if (state.config.firebase && state.user.name !== 'Anon') {
            els.userAvatar.innerText = state.user.name.substring(0,2).toUpperCase();
            initFirebase();
        } else { showSetup(false); }

        els.messageInput.addEventListener('input', (e) => els.sendBtn.classList.toggle('hidden', e.target.value.trim() === ''));
        async function sendText() {
            const txt = els.messageInput.value.trim();
            if (!txt) return;
            const { ref, push, set, serverTimestamp } = window.FirebaseMods;
            await set(push(ref(db, 'messages')), { type: 'text', userId: state.user.id, userName: state.user.name, content: txt, timestamp: serverTimestamp() });
            els.messageInput.value = '';
            els.sendBtn.classList.add('hidden');
        }
        els.sendBtn.addEventListener('click', sendText);
        els.messageInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') sendText(); });

        els.imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const { ref, push, set, serverTimestamp } = window.FirebaseMods;
            const { ref: sRef, uploadBytes, getDownloadURL } = window.FirebaseMods;
            const storageRef = sRef(storage, `images/${Date.now()}_${file.name}`);
            await uploadBytes(storageRef, file);
            const url = await getDownloadURL(storageRef);
            await set(push(ref(db, 'messages')), { type: 'image', userId: state.user.id, userName: state.user.name, content: url, timestamp: serverTimestamp() });
        });

        const startAction = (e) => { 
            e.preventDefault(); 
            audioEngine.startRecording(
                (sid, ch) => sendLiveChunk(sid, ch), 
                (blob, sid) => finalizeAudio(blob, sid)
            ); 
        };
        const stopAction = (e) => { 
            if (state.isRecording) {
                // Pasamos la función finalize al detener
                audioEngine.stopRecording((blob, sid) => finalizeAudio(blob, sid)); 
            }
        };

        els.micBtn.addEventListener('mousedown', startAction); 
        els.micBtn.addEventListener('touchstart', startAction); 
        els.micBtn.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); return false; });
        window.addEventListener('mouseup', stopAction); 
        window.addEventListener('touchend', stopAction);
        window.addEventListener('touchcancel', stopAction);

        function escapeHtml(text) { return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        lucide.createIcons();
    </script>
</body>
</html>
